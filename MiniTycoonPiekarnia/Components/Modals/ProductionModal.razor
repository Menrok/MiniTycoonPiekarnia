@implements IDisposable

<div class="modal-overlay" @onclick="Close"></div>
<div class="modal" @onclick:stopPropagation>
    <h2>Produkcja wypieków</h2>

    <div class="production-layout">
        <div class="production-left">
            @foreach (var product in GameState.Bakery.Products)
            {
                <div class="product-button" @onclick="() => TryStartProduction(product)">
                    <img src="images/products/@product.IconFile" alt="@product.Name" class="product-icon" />
                    <div class="ingredient-list">
                        @foreach (var req in product.RequiredIngredients)
                        {
                            var owned = GameState.Bakery.Ingredients.FirstOrDefault(i => i.Name == req.Key)?.Quantity ?? 0;
                            <div>@req.Key: @owned / @req.Value</div>
                        }
                    </div>
                </div>
            }
        </div>

        <div class="production-right">
            @if (GameState.ActiveProductions.Any())
            {
                <ul class="production-queue">
                    @foreach (var task in GameState.ActiveProductions)
                    {
                        var now = DateTime.Now;
                        var timePerItem = TimeSpan.FromSeconds(15);
                        double currentProgress = task.CurrentProgress;

                        if (task.LastStarted is DateTime started)
                        {
                            var elapsed = now - started;
                            currentProgress = Math.Min(1.0, elapsed.TotalSeconds / timePerItem.TotalSeconds);
                        }

                        var completedItems = task.TotalQuantity - task.QuantityRemaining;
                        var percent = (int)(((completedItems + currentProgress) / task.TotalQuantity) * 100);
                        var secondsLeft = (int)((task.QuantityRemaining - 1 + (1.0 - currentProgress)) * timePerItem.TotalSeconds);
                        var product = GameState.Bakery.Products.FirstOrDefault(p => p.Name == task.ProductName);

                        var taskClass = task.IsRunning ? "production-running" : "production-waiting";
                        var fillWidth = $"{percent}%";

                        <li class="@taskClass">
                            <div class="production-row">
                                <img src="images/products/@product?.IconFile" alt="@task.ProductName" class="production-icon" />

                                <div class="progress-bar">
                                    <div class="progress-fill" style="width:@fillWidth"></div>
                                    @if (task.IsRunning)
                                    {
                                        <span class="progress-text">@secondsLeft sek</span>
                                    }
                                </div>
                            </div>
                        </li>
                    }
                </ul>
            }
            else
            {
                <p>Brak aktywnych produkcji.</p>
            }
        </div>
    </div>
    @if (showPopupError)
    {
        <div class="error-popup @(fadeOut ? "fade-out" : "")">
            @errorMessage
        </div>
    }
</div>

@code {
    private string? errorMessage;

    protected override void OnInitialized() => GameState.OnChange += StateHasChanged;
    public void Dispose() => GameState.OnChange -= StateHasChanged;

    private void Close() => ModalService.CloseModal();

    private bool showPopupError = false;
    private bool fadeOut = false;

    private async void TryStartProduction(Product product)
    {
        errorMessage = null;

        var enough = product.RequiredIngredients.All(req =>
        {
            var ing = GameState.Bakery.Ingredients.FirstOrDefault(i => i.Name == req.Key);
            return ing != null && ing.Quantity >= req.Value;
        });

        if (!enough)
        {
            await ShowError("Brakuje składników!");
            StateHasChanged();
            return;
        }

        GameState.StartTimedProduction(product.Name, 1);
        await GameState.SaveGameAsync();
    }

    private async Task ShowError(string message)
    {
        errorMessage = message;
        showPopupError = true;
        fadeOut = false;
        StateHasChanged();

        await Task.Delay(700);
        fadeOut = true;
        StateHasChanged();

        await Task.Delay(500);
        showPopupError = false;
        StateHasChanged();
    }
}
