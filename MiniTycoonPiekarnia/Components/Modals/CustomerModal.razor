@implements IDisposable

<div class="modal-overlay" @onclick="Close"></div>
<div class="modal" @onclick:stopPropagation>
    <p>Nowy klient za: @SecondsUntilNextCustomer s</p>

    @if (GameState.Bakery.CustomersWaiting.Any())
    {
        <div class="customer-grid">
            @foreach (var customer in GameState.Bakery.CustomersWaiting)
            {
                var totalValue = customer.RequestedProducts.Sum(req =>
                GameState.Bakery.Products.First(p => p.Name == req.Key).SalePrice * req.Value);
                var timeLeft = customer.MaxWaitTime - (DateTime.Now - customer.TimeCreated);

                <div class="customer-box" @onclick="() => Fulfill(customer)">
                    <div class="customer-header">
                        <span><strong>Zamówienie</strong></span>
                        <span class="customer-timer">@timeLeft.Minutes:@timeLeft.Seconds</span>
                    </div>

                    <div class="customer-items">
                        @foreach (var item in customer.RequestedProducts)
                        {
                            <div>@item.Key x @item.Value</div>
                        }
                    </div>

                    <div class="customer-profit">@totalValue.ToString("0.00") zł</div>
                </div>
            }
        </div>
    }
    else
    {
        <p>Brak klientów.</p>
    }
</div>

@code {
    protected override void OnInitialized() => GameState.OnChange += StateHasChanged;
    public void Dispose() => GameState.OnChange -= StateHasChanged;

    private void Close() => ModalService.CloseModal();

    private int SecondsUntilNextCustomer =>
    Math.Max(0, (int)(GameState.CustomerInterval - (DateTime.Now - GameState.LastCustomerTime)).TotalSeconds);

    private void Fulfill(Customer customer)
    {
        GameState.FulfillCustomer(customer);
    }
}
