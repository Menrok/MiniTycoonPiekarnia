@implements IDisposable

<div class="modal-overlay" @onclick="Close"></div>
<div class="modal" @onclick:stopPropagation>
    <h2>Klienci oczekujący</h2>
    <p>🧍 Nowy klient za: @SecondsUntilNextCustomer s</p>

    @if (GameState.Bakery.CustomersWaiting.Any())
    {
        @foreach (var customer in GameState.Bakery.CustomersWaiting)
        {
            var totalValue = customer.RequestedProducts.Sum(req =>
            GameState.Bakery.Products.First(p => p.Name == req.Key).SalePrice * req.Value);

            var timeLeft = customer.MaxWaitTime - (DateTime.Now - customer.TimeCreated);
            <div class="customer-box">
                <p><strong>Zamówienie:</strong></p>
                <ul>
                    @foreach (var item in customer.RequestedProducts)
                    {
                        <li>@item.Key: @item.Value</li>
                    }
                </ul>
                <p>💰 Zysk: @totalValue.ToString("0.00") zł</p>
                <p>⌛ Pozostały czas: @timeLeft.Seconds s</p>
                <button @onclick="() => Fulfill(customer)">Sprzedaj</button>
            </div>
        }

    }
    else
    {
        <p>Brak klientów.</p>
    }

    <button class="close-button" @onclick="Close">Zamknij</button>
</div>

@code {
    protected override void OnInitialized() => GameState.OnChange += StateHasChanged;
    public void Dispose() => GameState.OnChange -= StateHasChanged;

    private void Close() => ModalService.CloseModal();

    private int SecondsUntilNextCustomer =>
    Math.Max(0, (int)(GameState.CustomerInterval - (DateTime.Now - GameState.LastCustomerTime)).TotalSeconds);

    private void Fulfill(Customer customer)
    {
        GameState.FulfillCustomer(customer);
    }
}
